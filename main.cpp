/*В начале программы подключаются необходимые библиотеки. Затем определен класс File для работы
 *  с файлами, содержащий методы для получения имени, размера и проверки наличия файла,
 *  а также метод обновления информации о файле. Класс Observer определяет методы для
 *  мониторинга нескольких файлов, включая список файлов, которые нужно отслеживать,
 *  и метод для запуска мониторинга.В функции main создается вектор строк с именами файлов,
 *  которые нужно отслеживать, и создается объект класса Observer, передавая ему вектор имен файлов.
 *  Затем запускается мониторинг файлов с помощью метода watch().
*/

#include <iostream>         // подключаем библиотеку для работы с вводом/выводом в консоль
#include <fstream>          // подключаем библиотеку для работы с файлами
#include <chrono>           // подключаем библиотеку для работы со временем
#include <thread>           // подключаем библиотеку для работы с многопоточностью
#include <vector>           // подключаем библиотеку для работы с векторами (динамическими массивами)
#include <Qstring>          // подключаем библиотеку для работы со строками в Qt
#include <QFileInfo>        // подключаем библиотеку для работы с информацией о файлах в Qt

using namespace std;         // определяем пространство имен, чтобы не писать std:: перед каждым объектом из стандартной библиотеки

class File                   // определяем класс для работы с файлами
 {
public:
    File(const string& name) : m_name(name), m_size(0), m_exists(false)      // конструктор класса, инициализирующий имя файла, его размер и флаг существования
    {

        update();              // вызываем метод для получения текущего размера файла
    }

    bool  exists() const        // метод, возвращающий флаг существования файла
    {
        return m_exists;
    }

    size_t size() const         // метод, возвращающий размер файла в байтах
    {
        return m_size;
    }

    const string& name() const  // метод, возвращающий имя файла в строчке string
    {
        return m_name;
    }

/*
Метод update() отвечает за обновление информации о файле, а именно проверку его существования и размера.
Для этого метод открывает файл с именем m_name с помощью объекта ifstream из стандартной библиотеки fstream.
Затем метод проверяет, удалось ли открыть файл, используя метод good() объекта file. Если удалось, то метод
устанавливает флаг существования файла m_exists в значение true, и устанавливает размер файла m_size, используя методы seekg()
и tellg() объекта file. При этом метод также сравнивает новый размер файла с предыдущим значением m_size, чтобы вывести сообщение о том
, что размер файла изменился.
Если открыть файл не удалось, то метод устанавливает флаг m_exists в значение false и размер файла m_size в значение 0.
*/
    void update()   //   отвечает за обновление информации о файле, а именно проверку его существования и размера.
{
        ifstream file(m_name);
        if (file.good())          // проверяем успешно ли открыт файл
        {
            m_exists = true;              // флаг существовования
            file.seekg(0, ios::end);       //   Затем, с помощью метода seekg, устанавливается указатель чтения в конец файла (начало,конец)
            size_t prev_size = m_size;        //присваиваем значение m_size  переменной prev_size, для дальнейший действий
            m_size = file.tellg();                // метод tellg() возвращает размер файла в байтах, находящийся в позиции конца файла.
            if (prev_size != 0 && prev_size != m_size)   // если размер файла изменился
                cout << "File " << m_name << " size chang  " << m_size << "  - new size." << endl;
        }
        else
        {
            m_exists = false;                            // иначе устанавливаем флаг несуществования файла
            m_size = 0;
        }
}

private:    // используя инкапсуляцию ,  защитить данные и методы объекта от неправильного использования в других частях программы
    string m_name;                 // имя файла
    size_t m_size;                 // размер файла
    bool m_exists;                 // флаг существования файла
};


class Observer                      // Определение класса "Observer", для мониторинга файлов
 {
public:
    // Конструктор класса, принимающий вектор имен файлов
    Observer(const vector<string>& filenames)    //принимает вектор строк filenames, который содержит имена файлов, которые нужно отслеживать. Конструктор итерируется по вектору и добавляет каждый файл в вектор m_files.
    {                                              // filename имеет тип константной ссылки на строку
        for (const auto& filename : filenames)    //цикл, итерирующий по вектору
        {
            m_files.emplace_back(filename);       //добавление нового объекта класса File в вектор m_files с именем файла filename
        }
    }
   // Метод, запускающий мониторинг файлов
    void watch()    // создаем таймер, который будет вызывать слот checkFiles() каждую секунду
    {
        while (true)          // бесконечный цикл
        {
            for (auto& file : m_files)      // Итерация по вектору файлов, каждый элемент вектора m_files будет доступен внутри цикла с помощью переменной file,тип переменной выводится автоматически на основе типа элементов в векторе
            {
                file.update();     // Обновляем информацию о файле
                if (file.exists())     // вызываем метод exists(), который выводит булево значение в if
                    cout << "File " << file.name() << " exists, size: " << file.size() << endl;
                else
                    cout << "File " << file.name() << " does not exist." << endl;
            }
            this_thread::sleep_for(chrono::seconds(1));
         cout<< "\n\n";
        }
    }

private:
    // вектор файлов, которые нужно отслеживать
   vector<File> m_files;
};
/*В функции main() мы создаем объект класса Observer и передаем ему вектор строк filenames, содержащий имена трех файлов. Затем мы вызываем метод watch()
 *для созданного объекта file_watcher.Метод watch() выполняет бесконечный цикл, в котором для каждого файла из вектора m_files вызывается метод update(),
 *который обновляет информацию о файле (его размер и флаг существования). Если файл существует, то выводится информация о его имени и размере, а если не существует,
 *  то выводится сообщение об отсутствии файла. Затем программа ждет одну секунду и повторяет цикл.Таким образом, программа непрерывно мониторит указанные
 * файлы и выводит информацию о них в консоль.
 */

int main()
{
    vector<string> filenames = {"C:/Qt/file1.txt", "C:/Qt/file2.txt", "C:/Qt/file3.txt"};     // список имен файлов, которые нужно отслеживать
    Observer file_watcher(filenames);                 // создаем объект класса Observer и передаем ему список файлов и указатель на приложение
    file_watcher.watch();                             // запускаем отслеживание файлов
}
